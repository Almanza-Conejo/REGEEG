function [singularValueDecomposition, spectralEnergyCoefficients]   =   regressionProcessing(varargin)

    %   This function performs singular value decomposition (SVD) on the input data
    %   and returns the decomposed matrices U, S, and V.
    inputData                           =   varargin{1};
    regressionDegree                    =   varargin{2};

    [samplesNumber, ~]                  =   size(inputData);
    inputData                           =   [inputData(:, 1)'; inputData(:, 2)'];
    firstInputPairElement               =   inputData(:, 1:samplesNumber-1);
    secondInputPairElement              =   inputData(:, 2:samplesNumber);
    
    % Angular vector computing
    firstAngularVector                  =   acos(firstInputPairElement(1, :)./sqrt(...
                                            firstInputPairElement(1, :).^2 + ...
                                            firstInputPairElement(2, :).^2));
    idxZeroValuesFromFirstElement       =   firstInputPairElement(1, :) == 0;
    firstAngularVector(idxZeroValuesFromFirstElement)        =   0;
    secondAngularVector                 =   acos(secondInputPairElement(1, :)./sqrt(...
                                            secondInputPairElement(1, :).^2 + ...
                                            secondInputPairElement(2, :).^2));
    idxZeroValuesFromSecondElement      =   secondInputPairElement(1, :) == 0;
    secondAngularVector(idxZeroValuesFromSecondElement)     =   0;
    differenceAngularVector             =   secondAngularVector - firstAngularVector;
    
    % Compute direction vector
    firstDirectionVectorElement         =   secondInputPairElement(1, :) - ...
                                            firstInputPairElement(1, :).*cos(differenceAngularVector) + ...
                                            firstInputPairElement(2, :).*sin(differenceAngularVector);
    secondDirectionVectorElement        =   secondInputPairElement(2, :) - ...
                                            firstInputPairElement(1, :).*sin(differenceAngularVector) - ...
                                            firstInputPairElement(2, :).*cos(differenceAngularVector);
    
    %   check MATLAB version to compute direction vector signals' energy
    matlabVersion                       =   ver;
    matlabYear                          =   year(matlabVersion(end).Date);
    %   extract spectral energy
    if matlabYear > 2016
        [angularSpectralEnergy, angularFrequency]                       =   ...
            pspectrum(differenceAngularVector);
        [firstDirectionElementSpectralEnergy, firstDirectionFrequency]  =   ...
            pspectrum(firstDirectionVectorElement);
        [secondDirectionElementSpectralEnergy, secondDirectionFrequency] =   ...
            pspectrum(secondDirectionVectorElement);
    else
        [angularSpectralEnergy, angularFrequency]                       =   ...
            periodogram(differenceAngularVector);
        [firstDirectionElementSpectralEnergy, firstDirectionFrequency]  =   ...
            periodogram(firstDirectionVectorElement);
        [secondDirectionElementSpectralEnergy, secondDirectionFrequency]=   ...
            periodogram(secondDirectionVectorElement);
    end

    %   compute logaritmic spectral energy
    angularSpectralEnergyLogarithmic                =   log(angularSpectralEnergy);
    firstDirectionElementSpectralEnergyLogarithmic  =   log(firstDirectionElementSpectralEnergy);
    secondDirectionElementSpectralEnergyLogarithmic =   log(secondDirectionElementSpectralEnergy);
    
    %   extract polynomial coefficients
    angularSpectralEnergyCoefficients               =   polyfit(...
                                                            angularFrequency, ...
                                                            angularSpectralEnergyLogarithmic, ...
                                                            regressionDegree);
    firstDirectionElementSpectralEnergyCoefficients =   polyfit(...
                                                            firstDirectionFrequency, ...
                                                            firstDirectionElementSpectralEnergyLogarithmic, ...
                                                            regressionDegree);
    secondDirectionElementSpectralEnergyCoefficients =   polyfit(...
                                                            secondDirectionFrequency, ...
                                                            secondDirectionElementSpectralEnergyLogarithmic, ...
                                                            regressionDegree);
    spectralEnergyCoefficients              =   [angularSpectralEnergyCoefficients, ...
                                                firstDirectionElementSpectralEnergyCoefficients, ...
                                                secondDirectionElementSpectralEnergyCoefficients];

    %   compute singular value decomposition matrix
    singularValueDecomposition              =   zeros(3, samplesNumber-1);
    for i = 1 : samplesNumber-1
        factorization                       =   [cos(differenceAngularVector(i)), - sin(differenceAngularVector(i)), firstAngularVector(i); ...
                                                sin(differenceAngularVector(i)), cos(differenceAngularVector(i)), secondAngularVector(i); ...
                                                0, 0, 1];
        singularValueDecomposition(:, i)    =   svd(factorization);
    end
end